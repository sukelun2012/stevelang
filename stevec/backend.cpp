/*
 * Copyright (c) 2024 Kekun Su(苏科纶).
 * 
 * Refer to the LICENSE file for full license information.
 * SPDX-License-Identifier: MIT
 */

#include "backend.h"
#include <iostream>
#include <sstream>
#include <cctype>

using namespace steve;
using namespace steve::AST;

namespace steve {
namespace Backend {

CodeGenerator::CodeGenerator() : out(nullptr), labelCounter(0), currentOffset(0) {}

CodeGenerator::~CodeGenerator() {}

void CodeGenerator::generate(AST::Program* prog, const std::string& outputFile) {
    std::ofstream fileOut(outputFile);
    if (!fileOut) {
        std::cerr << "Error: Could not open output file: " << outputFile << std::endl;
        return;
    }
    out = &fileOut;

    // Emit file header
    emitLine("; Steve Language Assembly Output");
    emitLine("; Generated by Steve Compiler");
    emitLine("");
    emitLine("section .data");
    emitLine("    newline db 10, 0");  // For print operations
    emitLine("");
    emitLine("section .text");
    emitLine("    global _start");
    emitLine("");
    emitLine("_start:");
    
    if (!prog) return;
    
    // Generate code for each top-level node
    for (auto &nptr : prog->topLevel) {
        genNode(nptr.get());
    }
    
    // Exit program
    emitLine("    ; Exit program");
    emitLine("    mov rax, 60");  // sys_exit
    emitLine("    mov rdi, 0");   // exit status
    emitLine("    syscall");
}

void CodeGenerator::genNode(AST::Node* n) {
    if (!n) return;
    if (auto s = dynamic_cast<Statement*>(n)) genStatement(s);
    else if (auto e = dynamic_cast<Expression*>(n)) genExpression(e);
}

void CodeGenerator::genStatement(AST::Statement* s) {
    if (!s) return;
    if (auto v = dynamic_cast<VarDecl*>(s)) genVarDecl(v);
    else if (auto f = dynamic_cast<FuncDecl*>(s)) genFuncDecl(f);
    else if (auto c = dynamic_cast<ClassDecl*>(s)) genClassDecl(c);
    else if (auto pd = dynamic_cast<PackageDecl*>(s)) genPackageDecl(pd);
    else if (auto b = dynamic_cast<BlockStmt*>(s)) genBlockStmt(b);
    else if (auto es = dynamic_cast<ExprStmt*>(s)) genExprStmt(es);
    else if (auto iff = dynamic_cast<IfStmt*>(s)) genIfStmt(iff);
    else if (auto ws = dynamic_cast<WhileStmt*>(s)) genWhileStmt(ws);
    else if (auto fs = dynamic_cast<ForStmt*>(s)) genForStmt(fs);
    else if (auto rs = dynamic_cast<ReturnStmt*>(s)) genReturnStmt(rs);
    else if (auto imp = dynamic_cast<ImportDecl*>(s)) genImportDecl(imp);
    else if (auto ts = dynamic_cast<TryStmt*>(s)) genTryStmt(ts);
    else if (auto bs = dynamic_cast<BreakStmt*>(s)) genBreakStmt(bs);
    else if (auto cs = dynamic_cast<ContinueStmt*>(s)) genContinueStmt(cs);
    else if (auto ps = dynamic_cast<PassStmt*>(s)) genPassStmt(ps);
}

void CodeGenerator::genExpression(AST::Expression* e) {
    if (!e) return;
    if (auto id = dynamic_cast<Identifier*>(e)) genIdentifier(id);
    else if (auto lit = dynamic_cast<Literal*>(e)) genLiteral(lit);
    else if (auto bin = dynamic_cast<BinaryExpr*>(e)) genBinaryExpr(bin);
    else if (auto u = dynamic_cast<UnaryExpr*>(e)) genUnaryExpr(u);
    else if (auto c = dynamic_cast<CallExpr*>(e)) genCallExpr(c);
    else if (auto m = dynamic_cast<MemberExpr*>(e)) genMemberExpr(m);
    else if (auto pma = dynamic_cast<PointerMemberAccess*>(e)) genPointerMemberAccess(pma);
    else if (auto ix = dynamic_cast<IndexExpr*>(e)) genIndexExpr(ix);
    else if (auto l = dynamic_cast<ListExpr*>(e)) genListExpr(l);
    else if (auto d = dynamic_cast<DictExpr*>(e)) genDictExpr(d);
}

void CodeGenerator::genVarDecl(AST::VarDecl* v) {
    // Handle pointer type declarations
    if (v->typeName.find("ptr<") != std::string::npos || 
        v->typeName.find("ref<") != std::string::npos || 
        v->typeName.find("weak<") != std::string::npos ||
        v->typeName.find("array_ptr<") != std::string::npos) {
        // This is a pointer type declaration
        emit("; Pointer variable declaration: " + v->name + " of type " + v->typeName);
        if (v->init) {
            genExpression(v->init.get());
            // Store the pointer value in the variable's location
            variables[v->name] = currentOffset;
            currentOffset += 8; // Pointers are 8 bytes on 64-bit systems
        } else {
            // Initialize pointer to null by default
            emit("    mov rax, 0  ; Initialize pointer to null");
            variables[v->name] = currentOffset;
            currentOffset += 8;
        }
    } else {
        // Regular variable declaration
        if (v->init) {
            emit("; Variable declaration with initialization: " + v->name);
            genExpression(v->init.get());
            // Store the value in the variable's location
            variables[v->name] = currentOffset;
            currentOffset += 8; // Assuming 8-byte slots for all values
        } else {
            emit("; Variable declaration: " + v->name);
            variables[v->name] = currentOffset;
            currentOffset += 8; // Assuming 8-byte slots for all values
        }
    }
}

void CodeGenerator::genFuncDecl(AST::FuncDecl* f) {
    emit("");
    emitLine(";" + f->name + " function");
    emitLine(f->name + ":");
    setupFunction(f->name, f->params);
    
    if (f->body) genStatement(f->body.get());
    
    teardownFunction();
}

void CodeGenerator::genIfStmt(AST::IfStmt* iff) {
    std::string endLabel = newLabel();
    std::string elseLabel = newLabel();
    
    // Generate condition
    genExpression(iff->cond.get());
    emit("    cmp rax, 0");  // Compare result with 0
    emit("    je " + elseLabel);  // Jump to else if condition is false
    
    // Then branch
    if (iff->thenBranch) genStatement(iff->thenBranch.get());
    emit("    jmp " + endLabel);
    
    // Else branch
    emit(elseLabel + ":");
    if (iff->elseBranch) genStatement(iff->elseBranch.get());
    
    emit(endLabel + ":");
}

void CodeGenerator::genWhileStmt(AST::WhileStmt* ws) {
    std::string condLabel = newLabel();
    std::string bodyLabel = newLabel();
    std::string endLabel = newLabel();
    
    emit(condLabel + ":");
    genExpression(ws->cond.get());
    emit("    cmp rax, 0");  // Compare result with 0
    emit("    je " + endLabel);  // Jump to end if condition is false
    
    emit(bodyLabel + ":");
    if (ws->body) genStatement(ws->body.get());
    emit("    jmp " + condLabel);  // Jump back to condition
    emit(endLabel + ":");
}

void CodeGenerator::genForStmt(AST::ForStmt* fs) {
    std::string condLabel = newLabel();
    std::string bodyLabel = newLabel();
    std::string endLabel = newLabel();
    
    // Initialize
    if (fs->init) genStatement(fs->init.get());
    
    emit(condLabel + ":");
    // Condition check
    if (fs->cond) {
        genExpression(fs->cond.get());
        emit("    cmp rax, 0");  // Compare result with 0
        emit("    je " + endLabel);  // Jump to end if condition is false
    }
    
    emit(bodyLabel + ":");
    if (fs->body) genStatement(fs->body.get());
    // Step
    if (fs->step) genExpression(fs->step.get());
    emit("    jmp " + condLabel);  // Jump back to condition
    emit(endLabel + ":");
}

void CodeGenerator::genReturnStmt(AST::ReturnStmt* rs) {
    if (rs->value) {
        genExpression(rs->value.get());
    } else {
        emit("    mov rax, 0");  // Default return value
    }
    emit("    ret");
}

void CodeGenerator::genExprStmt(AST::ExprStmt* es) {
    genExpression(es->expr.get());
}

void CodeGenerator::genBlockStmt(AST::BlockStmt* b) {
    for (auto &st : b->stmts) genNode(st.get());
}

void CodeGenerator::genCallExpr(AST::CallExpr* c) {
    // Handle special built-in functions first
    if (auto calleeId = dynamic_cast<Identifier*>(c->callee.get())) {
        std::string funcName = calleeId->name;
        if (funcName == "print") {
            // Handle print function
            emit("    ; print function call");
            if (!c->args.empty()) {
                genExpression(c->args[0].get()); // Evaluate argument to print
                // For simplicity, we'll just emit a placeholder for print
                emit("    ; Print value in rax");
            }
        } else if (funcName == "input") {
            emit("    ; input function call");
            emit("    ; Placeholder for input function");
            emit("    mov rax, 0");  // Default return for input
        } else if (funcName == "run") {
            emit("    ; run function call with 1 or 2 arguments");
            // Handle run function with 1 or 2 arguments
            if (c->args.size() == 1) {
                // run('filename.exe')
                genExpression(c->args[0].get()); // Evaluate the executable file name
                emit("    ; Execute file in rax");
                emit("    mov rax, 0");  // Default return value for now
            } else if (c->args.size() == 2) {
                // run('filename.exe', 'filename.txt') - execute first file with second as input
                genExpression(c->args[0].get()); // Evaluate the executable file name
                emit("    push rax"); // Save executable file name
                genExpression(c->args[1].get()); // Evaluate the input file name
                emit("    mov rbx, rax"); // Move input file name to rbx
                emit("    pop rax"); // Restore executable file name to rax
                emit("    ; Execute file in rax with input from rbx");
                emit("    mov rax, 0");  // Default return value for now
            } else {
                emit("    ; Invalid number of arguments for run function");
                emit("    mov rax, 0");  // Default return value
            }
        } else if (funcName == "new" || funcName == "delete" || funcName == "gc") {
            emit("    ; Garbage collection function: " + funcName);
            emit("    mov rax, 0");  // Default return for GC functions
        } else if (funcName == "malloc" || funcName == "free" || funcName == "realloc" || funcName == "calloc" ||
                   funcName == "memcpy" || funcName == "memmove" || funcName == "memcmp" || funcName == "memset" ||
                   funcName == "sizeofType" || funcName == "sizeofVar") {
            emit("    ; Memory management function: " + funcName);
            emit("    mov rax, 0");  // Default return for memory functions
        } else {
            // Regular function call
            emit("    call " + funcName);
        }
    } else {
        // More complex callee (like member function call)
        genExpression(c->callee.get());
        emit("    call rax");  // Call function pointer
    }
}

void CodeGenerator::genBinaryExpr(AST::BinaryExpr* b) {
    if (!b->left || !b->right) return;
    
    // Evaluate left operand
    genExpression(b->left.get());
    emit("    push rax");  // Save left operand
    // Evaluate right operand
    genExpression(b->right.get());
    emit("    mov rbx, rax");  // Move right operand to rbx
    emit("    pop rax");  // Restore left operand to rax
    
    // Perform operation based on operator
    if (b->op == "+") {
        emit("    add rax, rbx");
    } else if (b->op == "-") {
        emit("    sub rax, rbx");
    } else if (b->op == "*") {
        emit("    imul rax, rbx");
    } else if (b->op == "/") {
        emit("    cqo");  // Sign extend rax into rdx (for division)
        emit("    idiv rbx");
    } else if (b->op == "%") {
        emit("    cqo");
        emit("    idiv rbx");
        emit("    mov rax, rdx");  // Remainder is in rdx
    } else if (b->op == "==") {
        emit("    cmp rax, rbx");
        emit("    sete al");  // Set al to 1 if equal, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == "!=") {
        emit("    cmp rax, rbx");
        emit("    setne al");  // Set al to 1 if not equal, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == "<") {
        emit("    cmp rax, rbx");
        emit("    setl al");  // Set al to 1 if rax < rbx, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == ">") {
        emit("    cmp rax, rbx");
        emit("    setg al");  // Set al to 1 if rax > rbx, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == "<=") {
        emit("    cmp rax, rbx");
        emit("    setle al");  // Set al to 1 if rax <= rbx, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == ">=") {
        emit("    cmp rax, rbx");
        emit("    setge al");  // Set al to 1 if rax >= rbx, 0 otherwise
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (b->op == "and" || b->op == "&&") {
        emit("    and rax, rbx");
    } else if (b->op == "or" || b->op == "||") {
        emit("    or rax, rbx");
    } else {
        // Default: just return left operand
        emit("    ; Unknown binary operator: " + b->op);
    }
}

void CodeGenerator::genUnaryExpr(AST::UnaryExpr* u) {
    if (!u->operand) return;
    genExpression(u->operand.get());
    
    if (u->op == "-") {
        emit("    neg rax");  // Negate value
    } else if (u->op == "!") {
        emit("    cmp rax, 0");  // Compare with 0
        emit("    sete al");     // Set al to 1 if zero, 0 if non-zero
        emit("    movzx rax, al");  // Zero-extend to rax
    } else if (u->op == "~") {
        emit("    not rax");  // Bitwise NOT
    } else {
        // Default: return the operand value unchanged
    }
}

void CodeGenerator::genIdentifier(AST::Identifier* id) {
    // Look up the variable in our map
    auto it = variables.find(id->name);
    if (it != variables.end()) {
        // Variable exists, load its value
        int offset = it->second;
        emit("    mov rax, [rbp-" + std::to_string(offset) + "]");
    } else {
        // Variable not found, treat as function or return 0
        emit("    ; Identifier not found: " + id->name);
        emit("    mov rax, 0");
    }
}

void CodeGenerator::genLiteral(AST::Literal* lit) {
    // Try to convert the literal to a number
    try {
        // Check if it's a string literal (starts and ends with ")
        if (lit->raw.length() >= 2 && lit->raw[0] == '"' && lit->raw.back() == '"') {
            // String literal - for now just return 0 or a pointer value
            emit("    mov rax, 0  ; String literal placeholder");
        } else {
            // Numeric literal
            if (lit->raw.find('.') != std::string::npos) {
                // Float - for simplicity we'll treat as integer
                emit("    mov rax, " + std::to_string(static_cast<long long>(std::stod(lit->raw))));
            } else {
                // Integer
                emit("    mov rax, " + lit->raw);
            }
        }
    } catch (...) {
        // Not a valid number, return 0
        emit("    mov rax, 0");
    }
}

void CodeGenerator::genMemberExpr(AST::MemberExpr* m) {
    emit("    ; Member expression not fully implemented: ");
    emit("    mov rax, 0");  // Placeholder
}

void CodeGenerator::genPointerMemberAccess(AST::PointerMemberAccess* pma) {
    emit("; Pointer member access: " + pma->member);
    // First evaluate the pointer expression
    if (pma->pointer) {
        genExpression(pma->pointer.get());
        // rax now contains the pointer value
        // In a real implementation, this would access the member at the pointer location
        // For now, just emit a placeholder
        emit("    ; Dereference pointer and access member: " + pma->member);
        emit("    mov rax, 0");  // Placeholder return value
    } else {
        emit("    mov rax, 0");  // Default return
    }
}

void CodeGenerator::genIndexExpr(AST::IndexExpr* ix) {
    emit("    ; Index expression not fully implemented: ");
    emit("    mov rax, 0");  // Placeholder
}

void CodeGenerator::genListExpr(AST::ListExpr* l) {
    emit("    ; List expression not fully implemented: ");
    emit("    mov rax, 0");  // Placeholder
}

void CodeGenerator::genDictExpr(AST::DictExpr* d) {
    emit("    ; Dict expression not fully implemented: ");
    emit("    mov rax, 0");  // Placeholder
}

void CodeGenerator::genClassDecl(AST::ClassDecl* c) {
    emit("; Class declaration: " + c->name + " (not fully implemented in backend)");
}

void CodeGenerator::genImportDecl(AST::ImportDecl* imp) {
    emit("; Import declaration: " + imp->module + " (not implemented in backend)");
}

void CodeGenerator::genPackageDecl(AST::PackageDecl* pd) {
    emit("; Package declaration: " + pd->packageName);
}

void CodeGenerator::genTryStmt(AST::TryStmt* ts) {
    std::string catchLabel = newLabel();
    std::string endLabel = newLabel();
    
    // For now, just generate the try block since full exception handling is complex
    emit("; Try block");
    if (ts->tryBlock) genStatement(ts->tryBlock.get());
    emit("jmp " + endLabel);
    
    emit(catchLabel + ":");
    emit("; Catch block for exception: " + ts->exceptionVar);
    if (ts->catchBlock) genStatement(ts->catchBlock.get());
    
    emit(endLabel + ":");
}

void CodeGenerator::genBreakStmt(AST::BreakStmt* bs) {
    // For now, we'll just emit a placeholder
    emit("; BREAK statement");
}

void CodeGenerator::genContinueStmt(AST::ContinueStmt* cs) {
    // For now, we'll just emit a placeholder
    emit("; CONTINUE statement");
}

void CodeGenerator::genPassStmt(AST::PassStmt* ps) {
    // Pass statement does nothing
    emit("; PASS statement (no operation)");
}

std::string CodeGenerator::newLabel() {
    return "L" + std::to_string(labelCounter++);
}

void CodeGenerator::emit(const std::string& instruction) {
    if (out) {
        *out << instruction;
    }
}

void CodeGenerator::emitLine(const std::string& instruction) {
    if (out) {
        *out << instruction << std::endl;
    }
}

void CodeGenerator::setupFunction(const std::string& name, const std::vector<std::pair<std::string, std::string>>& params) {
    emitLine("    push rbp");
    emitLine("    mov rbp, rsp");
    
    // For simplicity, store parameters in our variable map
    // In a real implementation, we'd handle parameter passing properly
    int paramOffset = 16; // First parameter at rbp+16 (after return address and old rbp)
    for (size_t i = 0; i < params.size(); ++i) {
        variables[params[i].second] = -paramOffset; // Negative offset for parameters
        paramOffset += 8; // Assuming 8-byte slots
    }
}

void CodeGenerator::teardownFunction() {
    emitLine("    pop rbp");
    emitLine("    ret");
}

} // namespace Backend
} // namespace steve